{"version":3,"sources":["JS/ConverterFunctions.js","JS/Constants.js","JS/Modules/DelegateHolder.js","JS/Modules/Timer.js","JS/Modules/StopWatch.js","JS/Html_Manipulation.js","JS/index.js"],"names":["textTimeUnitsToSeconds","seconds","minutes","hours","secondsNumber","parseStringToTimeUnit","minutesNumber","hoursNumber","Math","round","minutesToSecondsRounded","hoursToSecondsRounded","userInput","includes","replace","possibleNumber","Number","isNaN","QS","SPAWN_BOX","LABLE_TEXT_SW","SPAWN_BTN","TRASH_ALL_BTN","COUNT_DIRECTION_BTN","INPUT_LABLE_FIELD","INPUT_SECONDS","INPUT_MINUTES","INPUT_HOURS","COUNTER_ARROW_SPAWN","LIST_SW","PLAY_BTN","PAUSE_BTN","RESET_BTN","TRASH_BTN","CLASS_TEXT_TIMER","COUNTER_ARROW","SEPARATION_BAR","ERROR_BAR_STARTIME","TOGGLE_CLASSES","PARTLY_OPACITY","BE_GONE","CSS_CLASSES","ARROW_UP","ARROW_DOWN","STORAGE_KEYS","STOP_WATCHES","GLOBAL_COUNT_DIRECTION","Object","freeze","DelegateHolder","_callbacks","callback","subscriber","_throwForInvalidCallback","_throwForInvalidObjectRef","subscriberArgs","push","_convertArgsList","length","i","splice","invoker","invokerArgs","callbackData","event","call","TypeError","objectRef","argList","argumentsForm","Timer","wantedType","_totalSeconds","_intervalId","_funcs","onTimeChange","_countDown","_totalSecondsStarting","countDown","setInterval","_incrementSeconds","_executeCallbacks","currentTotaleSeconds","clearInterval","stop","floor","ceil","Seconds","Minutes","Hours","negative","TotalSeconds","normalizedSeconds","toString","normalizedMinutes","normalizedHours","normalizedTime","totalSeconds","StopWatch","lableText","startingSeconds","currentSeconds","_currentState","States","reset","domReference","stopWatchDom","_labelText","_GetDomSubReference","textContent","_timeStampField","countingDown","_timer","setUpCurrentTime","TimeStamp","addCallback","_callbackUpdateTimeStamp","playBtn","playBtnClassName","pauseBtn","pauseBtnClassName","resetBtn","resetBtnClassName","trashBtn","trashBtnClassName","saveBtn","saveBtnName","counterArrow","countArrBtnClassName","timeCheckPoints","timeCheckPointsName","_throwForInvalidTimeUnit","counting","start","paused","firstChild","removeChild","remove","li","document","createElement","innerText","classList","add","toggleClassNumberNeg","toggleClassNumberPos","appendChild","stopWatch","timeStampField","contains","className","getElementsByClassName","propertyName","domQuerySelector","defineProperty","value","writable","labelText","totalSecondsStarting","currentState","innerHTML","jsObject","recreatedStopWatch","htmlElement","checkHTMLElementByClassName","timeUnit","container","children","classNameId","toggleVisibility","domElement","makeVisible","toggleCountDirectionBtn","countDirectionBtn","countDirectionInformation","get","btnText","title","titleText","toggleCounterSpawnerArrow","countArrowInformation","arrowWidget","classListArrow","manageErrorBar","errorBarInDom","errorRaised","isNotErrorBarDom","actionBtnPlay","selectedWatch","actionBtnReset","actionBtnPause","createdFromStorage","pause","CurrentState","actionBtnDelete","stopWatchList","separationBar","index","constructor","name","findIndex","indexOf","actionBtnDeleteAll","window","addEventListener","spawnBoxStopWatch","querySelector","containerForStopWatches","inputFieldLableStopWatch","spawnBtn","trashAllBtn","startSecondsInput","startMinutesInput","startHoursInput","counterArrowSpawn","Map","set","htmlManipulation","bind","callbackClickSpawnBox","target","trim","CreateStopWatch","parentNode","countDownGlobal","sessionStorage","setItem","JSON","stringify","callBackStopWatchContainer","isAPlyBtn","isATrashBtn","isAPauseBtn","isAResetBtn","isASaveBtn","setCheckPoint","callbackPress","eventTarget","key","code","pressedEnter","pressedBackspace","pressedDelete","focusedWatch","find","stopwatch","parse","getItem","stopWatchesState","forEach","uncreatedStopWatch","createdStopWatch","CreateFromJSObject","integrateStopWatch","lastState","listOfSavedStopWatches","unsavedStopWatch","jsObjectState","validateStartingTime","tabIndex"],"mappings":"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","file":"JS.bc7dd0ca.js","sourceRoot":"..","sourcesContent":["\r\n// @ts-check\r\n\r\n/**\r\n * Converts text time unites into seconds as one number value\r\n * Can also convert comma numbers. \r\n * It only contains digits with 2 exceptions\r\n * 1. Valid time unit has one comma or point at most. Such sign must not be\r\n * at the start or end of the time unit.\r\n * 2. Has one plus or minus at most. Such sign must be at the start of the unit. \r\n *  \r\n * @param {!string} seconds - supposed seconds as a string \r\n * @param {!string} minutes - supposed minutes as a string\r\n * @param {!string} hours - supposed hours as a string\r\n * @returns {?number} Returns total seconds from seconds, minutes and \r\n * hours or null if one the parameter can not be converted into a valid \r\n * number value.  \r\n */\r\nexport function textTimeUnitsToSeconds(seconds, minutes, hours) {\r\n\r\n    const secondsNumber = parseStringToTimeUnit(seconds);\r\n    const minutesNumber = parseStringToTimeUnit(minutes);\r\n    const hoursNumber = parseStringToTimeUnit(hours);\r\n\r\n    if (\r\n        secondsNumber === null || \r\n        minutesNumber === null || \r\n        hoursNumber === null\r\n    ) {\r\n        return null;\r\n    }\r\n\r\n    return (\r\n        Math.round(secondsNumber) + \r\n        minutesToSecondsRounded(minutesNumber) + \r\n        hoursToSecondsRounded(hoursNumber)\r\n        );\r\n}\r\n\r\n/**\r\n * Converts a string into a number value. Can also convert\r\n * strings as comma numbers. \r\n * \r\n * @param  {!string} userInput\r\n * @returns {?number} - Either a number value from userInput string\r\n * or null if the userInput was invalid for a number value  \r\n */\r\nexport function parseStringToTimeUnit(userInput) {\r\n    userInput = userInput.includes(\",\") ? \r\n    userInput.replace(\",\", \".\") : userInput;\r\n    let possibleNumber = Number(userInput);\r\n    return Number.isNaN(possibleNumber) === false ? possibleNumber : null;\r\n}\r\n\r\n/**\r\n * \r\n * @param {!number} minutes - minutes to be converted\r\n * @returns {!number} total seconds of the given minutes   \r\n */\r\nexport function minutesToSecondsRounded(minutes) {\r\n    return Math.round(minutes * 60);\r\n}\r\n\r\n/**\r\n * \r\n * @param {!number} hours - hours to be converted\r\n * @returns {!number} total seconds of the given hours   \r\n */\r\nexport function hoursToSecondsRounded(hours) {\r\n    return Math.round(hours * 3600);\r\n}\r\n","// query selector strings for getting dom elements.\r\nconst QS = {\r\n\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */    \r\n        SPAWN_BOX: \"#SpawnStopWatchBox\",\r\n                /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        LABLE_TEXT_SW: \".stop-watch-label-text\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        SPAWN_BTN: \"#spawn-btn\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        TRASH_ALL_BTN: \"#TrashAllButtons\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        COUNT_DIRECTION_BTN: \"#check-count-direction\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        INPUT_LABLE_FIELD: \"#InputFieldLableStopWatch\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        INPUT_SECONDS: \"#input-seconds\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        INPUT_MINUTES: \"#input-minutes\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        INPUT_HOURS: \"#input-hours\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        COUNTER_ARROW_SPAWN: \"#counter-arrow-spawn\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        LIST_SW: \"#stop-watch-list\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        PLAY_BTN: \".play-btn\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        PAUSE_BTN: \".pause-btn\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        RESET_BTN: \".reset-btn\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        TRASH_BTN: \".trash-btn\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        CLASS_TEXT_TIMER: \".text-timer\",        \r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        COUNTER_ARROW: \".counter-arrow\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        SEPARATION_BAR: \".separation-bar\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        ERROR_BAR_STARTIME: \".error-bar-start-time\",\r\n\r\n}\r\n\r\n\r\n\r\nconst TOGGLE_CLASSES = {\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        PARTLY_OPACITY: \"minorFocus\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n         */\r\n        BE_GONE: \"beGone\",\r\n}\r\n\r\nconst CSS_CLASSES = {\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n        */\r\n        ARROW_UP: \"fa-angle-double-up\",\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n        */\r\n        ARROW_DOWN: \"fa-angle-double-down\"\r\n}\r\n\r\nconst STORAGE_KEYS = {\r\n        /**\r\n         * @const\r\n         * @type {string}\r\n        */\r\n        STOP_WATCHES: \"stop-watches\",\r\n        GLOBAL_COUNT_DIRECTION: \"nextSWCountDown\"\r\n}\r\n\r\nObject.freeze(QS);\r\n\r\nexport { QS, TOGGLE_CLASSES, STORAGE_KEYS, CSS_CLASSES };","class DelegateHolder {\r\n    \r\n    constructor() {\r\n        // holds all attached callback functions\r\n        this._callbacks = [];\r\n    }\r\n\r\n    /**\r\n     * Attaches a callback functions to the instance. this callbacktion is then\r\n     * executed whenever the the instance calls the function executeCallbacks\r\n     *  \r\n     * Whenever a callback function is executed, it is provided with on parameter\r\n     * this parameter is a literal object with the property \r\n     * subscriber, subscriberArgs, invoker and invokerArgs\r\n     * \r\n     * @param {!callbacktion} callback - callbackt function to be executed  \r\n     * @param {?object} [subscriber=null] (optional) Provides the reference to the\r\n     * instance as subscriber which attached the callback functions \r\n     * @param {...any} [subscriberArgs] - (optional) A collection of parameters\r\n     * if more than one argument is provided the property args of the event object \r\n     * will be an list \r\n     * if only one argument is provided the property args will be this one parameter\r\n     * if no argument is provided the property will be null \r\n     * @returns {void} \r\n     * @throws {TypeError} - if parameter callback is not of type \"Function\"\r\n     * if parameter subscriberReference is not a nullable object \r\n     */\r\n    addCallback(callback, subscriber = null, ...subscriberArgs) {\r\n        _throwForInvalidCallback(callback);\r\n        _throwForInvalidObjectRef(subscriber);\r\n        \r\n        this._callbacks.push(\r\n            {\r\n                callback, \r\n                subscriber,\r\n                subscriberArgs: _convertArgsList(subscriberArgs)\r\n            } \r\n        );\r\n        \r\n    }\r\n\r\n    /**\r\n     * Removes an added callback function so it is not executed anymore\r\n     * when the function executeCallbacks is called\r\n     * \r\n     * @param {callbacktion} callback - reference to an added callback function which is \r\n     * to be removed \r\n     * @returns {void} \r\n     */\r\n    removeCallback(callback) {\r\n        _throwForInvalidCallback(callback);\r\n\r\n        const length = this._callbacks.length;\r\n        \r\n        for (let i = 0; i < length; i++ ) {\r\n\r\n            if (this._callbacks[i].callback === callback) {\r\n\r\n                this._callbacks.splice(i, 1);\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all registered callback functions\r\n     *  \r\n     * @returns {void}\r\n     */\r\n    clearCallbacks() {\r\n        this._callbacks = [];\r\n    }\r\n\r\n    /**\r\n     * Meant to be executed by the invoker.\r\n     * \r\n     * Executes all attached callback functions. Every callback function gets an event\r\n     * object as one argument passed. \r\n     * \r\n     * The event object can be supplemented with invoker and invokerArgs \r\n     * via the paramter of this function\r\n     *\r\n     * @param {?object} [invoker=null] - (optional) Reference to the instance executing \r\n     * the callback functions which have been attached by subscriber\r\n     * @param  {...any} invokerArgs - (optional) A collection of parameters\r\n     * if more than one argument is provided the property args of the event object \r\n     * will be an list \r\n     * if only one argument is provided the property args will be this one parameter\r\n     * if no argument is provided the property will be null \r\n     */\r\n    _executeCallbacks(invoker = null ,...invokerArgs) {\r\n        _throwForInvalidObjectRef(invoker);\r\n        \r\n        for (const callbackData of this._callbacks) {\r\n                        \r\n            const event = {\r\n                invoker,\r\n                invokerArgs: _convertArgsList(invokerArgs),\r\n                subscriber: callbackData.subscriber,\r\n                subscriberArgs: callbackData.subscriberArgs,\r\n            };\r\n\r\n            callbackData.callback.call(\r\n                invoker,\r\n                event\r\n            );\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction _throwForInvalidCallback(callback) {\r\n    if (callback === null || typeof(callback) !== \"function\") {\r\n        throw new TypeError(`\r\n        Callback callbacktion must be of type \"Function\"\r\n        `);\r\n    }\r\n}\r\n\r\nfunction _throwForInvalidObjectRef(objectRef) {\r\n    if (objectRef !== null && typeof objectRef !== \"object\") {\r\n        throw new TypeError(\"Reference to object must be null or a reference to an object !\");\r\n    }\r\n}\r\n\r\nfunction _convertArgsList(argList){\r\n    let argumentsForm = null;\r\n\r\n    if (argList.length === 1) {\r\n        argumentsForm = argList[0];\r\n    } else if ( argList.length >= 2) {\r\n        argumentsForm = argList;\r\n    }\r\n\r\n    return argumentsForm;\r\n}\r\n\r\nexport { DelegateHolder };","// @ts-check\r\nimport { DelegateHolder } from \"./DelegateHolder.js\";\r\n/** @module Timer */\r\n\r\n/** \r\n * Stores seconds, minutes and hours. Can be started and keeps counting until\r\n * it is stopped or reset. Can also execute attached callback functions whenever\r\n * it increments its seconds. \r\n*/\r\nclass Timer {\r\n    /**\r\n     * Takes the parameters to determine the starting time.\r\n     * Tip: You can just give seconds for the total amount of seconds \r\n     * It is also fine to give minutes over 60.\r\n     * \r\n     * @param {number} [seconds=0] - default: 0 (optional)\r\n     * @param {number} [minutes=0] - default: 0 (optional)\r\n     * @param {number} [hours=0] - default: 0 (optional)\r\n     * @throws {TypeError} if 1 param is null or not of the type number \r\n     */\r\n    constructor(seconds = 0, minutes = 0, hours = 0) {\r\n\r\n        const wantedType = \"number\";\r\n\r\n        if ( seconds === null || minutes === null || hours === null ) {\r\n\r\n            throw new TypeError(`\r\n            Constructor does not take a parameter which is null.\r\n            `);\r\n        } else if (\r\n\r\n            typeof(seconds) !== wantedType || typeof(minutes) !== wantedType || \r\n            typeof(hours) !== wantedType\r\n            )  {\r\n\r\n            throw new TypeError(\r\n                `Constructor does only take parameters of the type \r\n                \"${wantedType}\"`\r\n            );\r\n        } else {\r\n            \r\n            this._totalSeconds = seconds + (minutes * 60) + (hours * 3600);\r\n            \r\n            // Used to end interval code for incrementing seconds later\r\n            this._intervalId = null;\r\n\r\n            // Holds references of the callback functions attached from outside\r\n            // via this.addFuncOnChange and the arguments \r\n            // for the callback functions. \r\n            this._funcs = [];\r\n        }\r\n\r\n        this.onTimeChange = new DelegateHolder();\r\n        this._countDown = false;\r\n        this._totalSecondsStarting = this._totalSeconds; \r\n    }\r\n\r\n    // Getters\r\n\r\n    /**\r\n     * Rest of seconds after hours and minutes conversion\r\n     * @member {number} \r\n     * @readonly    \r\n     */\r\n    get Seconds() {\r\n        return this._totalSeconds % 60;\r\n    }\r\n\r\n    /**\r\n     * Rest of minutes after hours conversion\r\n     * \r\n     * @readonly\r\n     * @member {number}   \r\n     */\r\n    get Minutes() {\r\n        let minutes = this._totalSeconds / 60;\r\n        \r\n        minutes = this._totalSeconds >= 0 \r\n        ? Math.floor(minutes) : Math.ceil(minutes);        \r\n        \r\n        minutes%=60\r\n        return minutes === -0 ? 0 : minutes; \r\n    }\r\n\r\n    /**\r\n     * whole number of total hours.\r\n     * \r\n     * @readonly\r\n     * @member {number}    \r\n     */\r\n    get Hours() {\r\n        let hours = this._totalSeconds / 3600;\r\n        hours = this._totalSeconds >= 0 ? Math.floor(hours) : Math.ceil(hours);        \r\n        return hours === -0 ? 0 : hours;\r\n    }\r\n\r\n    /**\r\n     * Get the time in total seconds\r\n     * @readonly\r\n     * @member {number}\r\n     * @example timer with Seconds: 20, Minutes: 2, Hours: 1\r\n     * would return 3740\r\n     * (20 + 2*60 + 1*60*60)\r\n     */\r\n    get TotalSeconds() {\r\n        return this._totalSeconds;         \r\n    }\r\n\r\n    /**\r\n     * Format for the time, Hours:Minutes:Seconds\r\n     * if the time is negative 1 minus will be prepended \r\n     * to the time stamp \r\n     * @member {string} \r\n     * @readonly\r\n     * \r\n     * @example  \r\n     * 20:45:02 for Seconds: 02, Minutes: 45, Hours: 20\r\n     * -0:10:20 for Seconds: -20, Minutes: -10, Hours: 0\r\n     */\r\n    get TimeStamp() {\r\n        let seconds = this.Seconds;\r\n        let minutes = this.Minutes;\r\n        let hours = this.Hours;\r\n        let negative = false;\r\n\r\n        if (this.TotalSeconds < 0) {\r\n\r\n            seconds *= -1;\r\n            minutes *= -1;\r\n            hours *= -1;\r\n            negative = true;\r\n        }\r\n\r\n        let normalizedSeconds = seconds >= 10 ? \r\n        seconds.toString() : `0${seconds.toString()}`\r\n\r\n        let normalizedMinutes = minutes >= 10 ? \r\n        minutes.toString() : `0${minutes.toString()}`\r\n\r\n        let normalizedHours = hours >= 10 ? \r\n        hours.toString() : `0${hours.toString()}`;\r\n\r\n        let normalizedTime = \r\n        `\r\n        ${normalizedHours}:${normalizedMinutes}:${normalizedSeconds}\r\n        `;\r\n\r\n        return negative === false ? normalizedTime : `${normalizedTime}`;\r\n    }\r\n\r\n    // Routines\r\n\r\n    _incrementSeconds () {\r\n        if (this._countDown === false) this._totalSeconds++;\r\n        else this._totalSeconds--;\r\n    }\r\n\r\n    // Intended exposed methods.\r\n\r\n    /**\r\n    * Starts/Resume counting the time up or down every second.\r\n    * @param {?boolean} [countDown=null] - if true the timer \r\n    * counts up every second if false the timer counts down every second\r\n    * if null the counting direction will be the same before the time was stopped\r\n    * if the timer was not stopped yet then the timer counts up by default \r\n    * @return {void}\r\n    */\r\n    start(countDown=null) {\r\n        this._countDown = countDown !==null ? countDown : this._countDown;\r\n        \r\n        this._intervalId = setInterval(() => {\r\n            this._incrementSeconds(); \r\n            this.onTimeChange._executeCallbacks(this);\r\n        }, 1000);\r\n    }\r\n\r\n    /**\r\n     * Sets the current time of the timer.\r\n     * If reset, it will revert to the Getter \"totalSecondsStarting\" however\r\n     * \r\n     * @param {!number} currentTotaleSeconds - total seconds the timer\r\n     * will count from when started or will be set to if it already counts.\r\n     * \r\n     */\r\n    setUpCurrentTime(currentTotaleSeconds) {        \r\n        this._totalSeconds = currentTotaleSeconds\r\n    }\r\n        \r\n    /**\r\n    *\r\n    * Stops the counting but keeps the accumulated time \r\n    * \r\n    * @return {void} \r\n    */\r\n    stop() {\r\n\r\n        if (this._intervalId !== null) {\r\n\r\n            clearInterval(this._intervalId);\r\n            this._intervalId = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Stops the counting and sets time of the timer\r\n    * to the state it was when created\r\n    * \r\n    * @return {void}\r\n    * @example const timer = new Timer(23);\r\n    * timer.start();\r\n    * // After 5 Second\r\n    * timer: Seconds: 28, Minutes: 0, Hours: 0\r\n    * timer.reset();\r\n    * timer: Seconds: 23, Minutes: 0, Hours: 0 \r\n    */    \r\n    reset() {\r\n        this._totalSeconds = this._totalSecondsStarting;\r\n        this._countDown = false;\r\n        this.onTimeChange._executeCallbacks(this);\r\n        this.stop();\r\n    }\r\n\r\n    /**\r\n     * Gets the current starting time at which \r\n     * the timer starts counting from if started.\r\n     *\r\n     * @type {!number} - time which the timer should be set to\r\n     */\r\n    get totalSecondsStarting() {\r\n        return this._totalSecondsStarting;\r\n    }\r\n\r\n    /**\r\n     * Set up a new time so in case the timer gets restarted,\r\n     * timer starts counting at this new time\r\n     * \r\n     * @param {!number} totalSeconds - new time at which the\r\n     * timers starts counting after a reset\r\n    */    \r\n    set totalSecondsStarting(totalSeconds) {\r\n        \r\n        if ( totalSeconds === null || typeof totalSeconds !== \"number\" ) {\r\n            throw new TypeError(\"New starting time must be of type number\");\r\n        }\r\n\r\n        this._totalSecondsStarting = totalSeconds;\r\n    }\r\n\r\n}\r\n\r\nexport { Timer };","// @ts-check\r\n\r\nimport { Timer } from \"./Timer.js\";\r\n\r\nclass StopWatch {\r\n\r\n    /**\r\n     * \r\n     * \r\n     * @param {!string} lableText - Title in the upper left corner \r\n     * for describing the stop watch\r\n     * @param {?number} [startingSeconds=null] - time at which the stop watch reverts back to\r\n     * if being reset\r\n     * @param {!number} [currentSeconds=0] - time at which the stop watches starts from for\r\n     * first time of starting it\r\n     */\r\n    constructor( lableText, startingSeconds = 0, currentSeconds = null) {\r\n        \r\n        this._currentState = StopWatch.States.reset;\r\n        // Creating the html model for the stop watch\r\n        this.domReference = stopWatchDom(); \r\n\r\n        // Stores text for possible conversion to a plain js object\r\n        this._labelText = lableText;\r\n        this._GetDomSubReference(\"stop-watch-label-text\").textContent = lableText;\r\n            \r\n        // Reference to the paragraph for presenting the current time on the stop watch\r\n        this._timeStampField = this._GetDomSubReference(\"text-timer\");\r\n        \r\n        this.countingDown = false;\r\n\r\n        // Inner timer for counting time.\r\n        this._timer = new Timer(startingSeconds);      \r\n        this._timer.setUpCurrentTime( currentSeconds ?? startingSeconds );\r\n        this._timeStampField.textContent = this._timer.TimeStamp;\r\n        \r\n        this._timer.onTimeChange.addCallback(this._callbackUpdateTimeStamp, this);        \r\n\r\n        // Public references to relevant sub html elements\r\n        this.playBtn = this._GetDomSubReference(playBtnClassName);\r\n        this.pauseBtn = this._GetDomSubReference(pauseBtnClassName);\r\n        this.resetBtn = this._GetDomSubReference(resetBtnClassName);\r\n        this.trashBtn = this._GetDomSubReference(trashBtnClassName);\r\n        this.saveBtn = this._GetDomSubReference(saveBtnName);\r\n        this.counterArrow = this._GetDomSubReference(countArrBtnClassName);\r\n        this.timeCheckPoints = this._GetDomSubReference(timeCheckPointsName);\r\n\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @readonly\r\n     * @type {!number} - Represents the current state of a stop watch\r\n     */\r\n    get CurrentState() {\r\n        return this._currentState;\r\n    }\r\n\r\n    /**\r\n     * Is true if timer was not started since a reset or the creation.\r\n     * \r\n     * @readonly \r\n     * @type {!boolean}\r\n     */\r\n    get isAtStart() {\r\n        return this._timer._totalSecondsStarting === this._timer.TotalSeconds;\r\n    }\r\n\r\n    /**\r\n     * Gets an literal object that represents the current state\r\n     * of its internal timer\r\n     * \r\n     * Is used to store it and later recreate a stop watch \r\n     * with the function CreateStopWatch in the index file  \r\n     * @readonly\r\n     * @type {!object} \r\n     */\r\n    get jsObjectState() {\r\n        return {\r\n            totalSeconds: this._timer.TotalSeconds,\r\n            countingDown: this.countingDown,\r\n            labelText: this._labelText,\r\n            startingSeconds: this._timer.totalSecondsStarting,\r\n            currentState: this._currentState,\r\n            timeCheckPoints: this.timeCheckPoints.innerHTML            \r\n        };\r\n    }\r\n\r\n    /**\r\n     * Stops the timers counting and resets it to\r\n     * to a new starting time given by the parameters\r\n     * \r\n     * @param {!number} [seconds=0] - (optional) New starting time\r\n     * @returns {void}\r\n     * @throws {TypeError} throws if parameter seconds is not of type number\r\n     */\r\n    setUpTimer(seconds) {\r\n        _throwForInvalidTimeUnit(seconds);\r\n        this._currentState = StopWatch.States.reset;                \r\n        this._timeStampField.textContent = this._timer.TimeStamp; \r\n    }\r\n\r\n    /**\r\n     * Starts the internal timer if timer has not started yet.\r\n     * \r\n     * @returns {!boolean} - Returns true if the internal timer was started\r\n     * by this call. \r\n     * Returns false if the timer was already started before this call\r\n     */\r\n    start() {\r\n        if (this._currentState !== StopWatch.States.counting) {            \r\n            this._timer.start(this.countingDown);\r\n            this._currentState =  StopWatch.States.counting;\r\n            return true;\r\n        } else return false;        \r\n    }\r\n\r\n    /**\r\n     * Pauses the internal timer if the timer is not already paused.\r\n     * \r\n     * @returns {!boolean} - Returns true if internal timer was paused \r\n     * by this call.\r\n     * Returns false if the internal timer was already paused before this call\r\n     */\r\n    pause() {\r\n        if (\r\n            this._currentState !== StopWatch.States.reset &&\r\n            this._currentState !== StopWatch.States.paused \r\n            ) {\r\n            this._timer.stop();\r\n            this._currentState = StopWatch.States.paused;\r\n            return true;\r\n        } else return false;\r\n    }\r\n\r\n    /**\r\n     * Stops the internal timer and sets its value back the starting time\r\n     * \r\n     * @returns {void}\r\n     */\r\n    reset() {\r\n        this._currentState = StopWatch.States.reset;\r\n        \r\n        // Removes all time check points from a stop watch\r\n        while (this.timeCheckPoints.firstChild !== null) {\r\n            this.timeCheckPoints.removeChild(this.timeCheckPoints.firstChild);\r\n        }\r\n\r\n        this._timer.reset();\r\n    }\r\n\r\n    /**\r\n     * Stops the internal timer and then removes the \r\n     * stop watch dom element from the dom\r\n     * \r\n     * @returns {void}\r\n     */\r\n    remove() {\r\n        this._timer.stop();\r\n        this.domReference.remove();     \r\n    }\r\n\r\n    /**\r\n     * Creates a separate time stamp from the current one and places into the stop watch\r\n     * These time stamps will remain until a reset.\r\n     */\r\n    setCheckPoint() {\r\n        const li = document.createElement('li');\r\n        li.innerText = `${this._timer.TimeStamp}`;\r\n\r\n        if (this._timer.TotalSeconds < 0) {\r\n            li.classList.add(toggleClassNumberNeg);\r\n        } else {\r\n            li.classList.add(toggleClassNumberPos);\r\n        }\r\n\r\n        this.timeCheckPoints.appendChild(li);\r\n    }\r\n\r\n    /**\r\n     * Can create an instance of stop watch from a correct plain js object.\r\n     * The getter jsObject of an instance returns such a plain js object. \r\n     * \r\n     * @param {!object} jsObject\r\n     * @returns {!StopWatch} Instance of a stop watch with the state before it was\r\n     * saved as a plain js object.\r\n     */\r\n    static CreateFromJSObject( jsObject ) {\r\n\r\n        // let checkIfThere = prop => typeof(prop) === \"undefined\";\r\n        let recreatedStopWatch = new StopWatch(\r\n            jsObject.labelText, \r\n            jsObject.startingSeconds,\r\n            jsObject.totalSeconds           \r\n        );\r\n\r\n        recreatedStopWatch.countingDown = jsObject.countingDown;\r\n\r\n        recreatedStopWatch.timeCheckPoints.innerHTML = jsObject.timeCheckPoints;\r\n\r\n        return recreatedStopWatch;        \r\n    }\r\n\r\n    /**\r\n     * Checks if an html element is a play button of a stop watch dom object\r\n     * \r\n     * @param {?HTMLElement} htmlElement - full css class string to check of the html element\r\n     * for checking. \r\n     * @returns {!boolean} Returns true if html element is part of the dom presentation \r\n     * of a stop watch otherwise it returns false\r\n     */\r\n    static isAPlyBtn (htmlElement) {\r\n        return checkHTMLElementByClassName(\r\n            htmlElement, \r\n            playBtnClassName\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if an html element is a pause button of a stop watch dom object\r\n     * \r\n     * @param {?HTMLElement} htmlElement - full css class string to check of the html element\r\n     * for checking. \r\n     * @returns {!boolean} Returns true if html element is part of the dom presentation \r\n     * of a stop watch otherwise it returns false\r\n     */\r\n    static isAPauseBtn (htmlElement) {\r\n        return checkHTMLElementByClassName(\r\n            htmlElement, \r\n            pauseBtnClassName\r\n        );   \r\n    }\r\n\r\n    /**\r\n     * Checks if an html element is a trash button of a stop watch dom object\r\n     * \r\n     * @param {?HTMLElement} htmlElement - full css class string to check of the html element\r\n     * for checking. \r\n     * @returns {!boolean} Returns true if html element is part of the dom presentation \r\n     * of a stop watch otherwise it returns false\r\n     */\r\n    static isATrashBtn (htmlElement) {\r\n        return checkHTMLElementByClassName(\r\n            htmlElement, \r\n            trashBtnClassName\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if an html element is a reset button of a stop watch dom object\r\n     * \r\n     * @param {?HTMLElement} htmlElement - full css class string to check of the html element\r\n     * for checking. \r\n     * @returns {!boolean} Returns true if the html element is button of a stop watch \r\n     */\r\n    static isAResetBtn (htmlElement) {\r\n        return checkHTMLElementByClassName(\r\n            htmlElement, \r\n            resetBtnClassName\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if an html element is a save button of a stop watch dom object\r\n     * \r\n     * @param {?HTMLElement} htmlElement - full css class string to check of the html element\r\n     * for checking. \r\n     * @returns {!boolean} Returns true if the html element is button of a stop watch\r\n     */\r\n    static isASaveBtn(htmlElement) {\r\n        return checkHTMLElementByClassName(\r\n            htmlElement, \r\n            saveBtnName\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * Used to apply changes of internal timer to the stop watch html element\r\n     * so the user can see the new time. It also applies a color to the font\r\n     * of the time stamp depending on the time being under zero.\r\n     * @callback\r\n     */\r\n    _callbackUpdateTimeStamp(event) {\r\n\r\n        const stopWatch = event.subscriber; \r\n        const timeStampField = stopWatch._timeStampField;\r\n\r\n        timeStampField.textContent = event.invoker.TimeStamp;\r\n        \r\n        if (stopWatch._timer.TotalSeconds < 0 ) {\r\n            if (timeStampField.classList.contains(toggleClassNumberNeg) !== true) {\r\n                timeStampField.classList.remove(toggleClassNumberPos);\r\n                timeStampField.classList.add(toggleClassNumberNeg);\r\n            }            \r\n        } else {\r\n            if (timeStampField.classList.contains(toggleClassNumberPos) !== true) {\r\n                timeStampField.classList.remove(toggleClassNumberNeg);\r\n                timeStampField.classList.add(toggleClassNumberPos);\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    // Gets respective sub html element of the html model of the stop watch.\r\n    // querySelector - query string used for finding a html element  \r\n    _GetDomSubReference (className) {\r\n        return this.domReference.getElementsByClassName(className)[0];\r\n    }\r\n\r\n    // Used to create properties with dom references as values \r\n    // on the instance at runtime\r\n    _CreateSubElementReference({ propertyName, domQuerySelector }) {\r\n        Object.defineProperty(this, propertyName, {\r\n            value: this._GetDomSubReference(domQuerySelector),\r\n            writable: false\r\n        });        \r\n    }\r\n    \r\n}\r\n\r\n/**\r\n * Is a readonly object as enumerator for the current state of a stop watch\r\n * The current state can be accessed by the Getter \"CurrentState\"\r\n * \r\n * @enum {!number} - Possible states are reset, counting and paused.\r\n */\r\nStopWatch.States = Object.freeze({\r\n    reset: 0,\r\n    counting: 1,\r\n    paused: 2\r\n});\r\n\r\nconst toggleClassNumberPos = \"positive\";\r\nconst toggleClassNumberNeg = \"negative\";\r\n\r\n// Classnames used to get references to sub html elements\r\nconst playBtnClassName = \"play-btn\";\r\nconst pauseBtnClassName = \"pause-btn\";\r\nconst resetBtnClassName = \"reset-btn\";\r\nconst trashBtnClassName = \"trash-btn\";\r\nconst saveBtnName = \"save-btn\";\r\nconst countArrBtnClassName = \"counter-arrow\";\r\nconst timeCheckPointsName = \"time-check-points\" ;\r\n\r\n\r\n// Used to validate the time units as valid numbers\r\nfunction _throwForInvalidTimeUnit(timeUnit) {\r\n    if (timeUnit === null || typeof timeUnit !== \"number\") {\r\n        throw new TypeError(\"Time unit must be of type 'number' \");\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a box which serves as a stop watch. It has a title, \r\n * time stamp lable for showing time and widgets as buttons the \r\n * for user to control it. \r\n * \r\n * @returns {!object} - dom elements representing a stop watch\r\n */\r\nfunction stopWatchDom()  {\r\n    const container = document.createElement(\"div\");\r\n\r\n    container.innerHTML = \r\n`\r\n<div class=\"stop-watch\">\r\n    <div class=\"stop-watch-row-label\">\r\n        <p class=\"stop-watch-label-text\"></p>\r\n        <i class=\"btn trash-btn fas fa-trash-alt\"></i>\r\n    </div>\r\n    <div class=\"stop-watch-row-timer\">\r\n        <i class=\"btn play-btn fas fa-play\"></i>\r\n        <i class=\"btn pause-btn fas fa-pause\"></i>\r\n        <i class=\"btn reset-btn fas fa-stop\"></i> \r\n        <i class=\"fas counter-arrow\"></i> \r\n        <i class=\"btn save-btn fas fa-save\"></i>     \r\n        <p class=\"text-timer\">23:54:02</p>\r\n    </div>\r\n    <ul class=\"time-check-points\">\r\n        \r\n    </ul>\r\n</div>\r\n`;\r\n\r\n    return container.children[0];\r\n}\r\n\r\n\r\n\r\n/**\r\n * \r\n * @param {?HTMLElement} htmlElement\r\n * @param {!string} classNameId\r\n * @returns {!boolean} \r\n */\r\nfunction checkHTMLElementByClassName(htmlElement, classNameId) {\r\n    if (htmlElement === null) return false;\r\n    const className = htmlElement.className;\r\n    return className.includes(classNameId);    \r\n}\r\n\r\n\r\n\r\nexport { StopWatch }","// @ts-check\r\nimport { TOGGLE_CLASSES, CSS_CLASSES } from \"./Constants.js\";\r\nimport { StopWatch } from \"./Modules/StopWatch.js\";\r\n\r\n/**\r\n * Makes a dom element invisible and removes it from the document flow\r\n * Or makes an element visible again and reintegrates \r\n * into the document flow \r\n * \r\n * @param {!HTMLElement} domElement - Dom element to change \r\n * @param {!boolean} makeVisible - If true dom element will be made\r\n * invisible and put out of the document flow if false vise versa\r\n */\r\nexport function toggleVisibility(domElement, makeVisible) {\r\n    if (makeVisible === true) domElement.classList.remove(TOGGLE_CLASSES.BE_GONE);\r\n    else domElement.classList.add(TOGGLE_CLASSES.BE_GONE);        \r\n}\r\n\r\n/**\r\n * Toggles text content and title as tooltip of the button for\r\n * setting the counting direction of the next stop watch.\r\n * \r\n * @param {!HTMLElement} countDirectionBtn - button which changes the counting direction\r\n * of the next spawn button to spawn if clicked.\r\n * @param {Map<!boolean, object>} countDirectionInformation - key is true if next stop watch\r\n * will count up otherwise down. Value is has 2 properties. btnText is the text content of\r\n * button which indicates a counting direction switch if clicked. titleText the pop up text \r\n * if hovered over the countDirectionBtn\r\n * @param {!boolean} countDown - the current direction in which the next stop watch will count\r\n *\r\n */\r\nexport function toggleCountDirectionBtn(countDirectionBtn, countDirectionInformation, countDown) {\r\n    countDirectionBtn.textContent = countDirectionInformation\r\n    .get(countDown).btnText;\r\n    countDirectionBtn.title = countDirectionInformation\r\n    .get(countDown).titleText;\r\n}\r\n\r\n/**\r\n * Changes the appearance and its pop up hover title of an arrow \r\n * for showing the counting direction of a stop watch\r\n * \r\n * @param {!Map<!boolean, !string>} countArrowInformation - Map which contains a\r\n * 2 strings for the content of a button for saying if user wants to count down or up\r\n * with the next stop watch.\r\n * @param {!boolean} countDown - If true the arrow will represent \r\n * counting up if false the arrow will represent counting down\r\n * @param {HTMLElement} arrowWidget - the arrow icon as html element to toggle its\r\n * change its class for the appearance and its tile as tooltip\r\n * @returns {void} \r\n */\r\nexport function toggleCounterSpawnerArrow(countArrowInformation, countDown, arrowWidget) {\r\n    const classListArrow = arrowWidget.classList; \r\n    \r\n    if (countDown === true) {\r\n        classListArrow.remove(CSS_CLASSES.ARROW_UP);\r\n        classListArrow.add(CSS_CLASSES.ARROW_DOWN);\r\n        arrowWidget.title = countArrowInformation\r\n        .get(true);\r\n    } else {\r\n        classListArrow.add(CSS_CLASSES.ARROW_UP);\r\n        classListArrow.remove(CSS_CLASSES.ARROW_DOWN);\r\n        arrowWidget.title = countArrowInformation\r\n        .get(false);\r\n    }\r\n}\r\n\r\n/**\r\n * Toggles visibility and influence on the document flow for the error bar. \r\n * If user provides wrong input the error bar is visible and \r\n * is located between the spawn box and the list of stop watches. \r\n * If user provides something valid with the next input, \r\n * the error bar gets invisible and is removed from the grid flow. \r\n * \r\n * @param {!HTMLElement} errorBarInDom - html element which represents an error bar.\r\n * @param {!boolean} errorRaised - true if the user provided wrong input\r\n *\r\n */\r\nexport function manageErrorBar(errorBarInDom, errorRaised, ) {\r\n   \r\n    const isNotErrorBarDom = errorBarInDom\r\n    .classList.contains(TOGGLE_CLASSES.BE_GONE);\r\n \r\n    if (errorRaised === true && isNotErrorBarDom === true ) {            \r\n        errorBarInDom.classList.remove(TOGGLE_CLASSES.BE_GONE);                        \r\n    } else if (errorRaised === false && isNotErrorBarDom === false) {\r\n        errorBarInDom.classList.add(TOGGLE_CLASSES.BE_GONE);            \r\n    }\r\n \r\n};   \r\n\r\n/**\r\n * Performs all actions needed to be done when the play button\r\n * is pressed. Changing opacity of buttons and reactivate \r\n * the counting of the internal timer\r\n * \r\n * @param {!StopWatch} selectedWatch - stop watch do all the\r\n * actions on \r\n * @returns {void} \r\n */\r\nexport function actionBtnPlay(selectedWatch) {\r\n    selectedWatch.playBtn\r\n    .classList.add(TOGGLE_CLASSES.PARTLY_OPACITY);\r\n    selectedWatch.pauseBtn\r\n    .classList.remove(TOGGLE_CLASSES.PARTLY_OPACITY);\r\n    selectedWatch.resetBtn\r\n    .classList.remove(TOGGLE_CLASSES.PARTLY_OPACITY);    \r\n\r\n    selectedWatch.start();\r\n    // Should only make reset btn apparent if the play is clicked \r\n    // while stop watch is reset or paused. \r\n    \r\n}\r\n\r\n/**\r\n * Performs all actions needed to be done when the reset button\r\n * is pressed. Changing opacity of buttons and resets \r\n * the time of a stop watch\r\n * \r\n * @param {!StopWatch} selectedWatch - stop watch do all the\r\n * actions on \r\n * \r\n */\r\nexport function actionBtnReset(selectedWatch) {            \r\n    selectedWatch.playBtn\r\n    .classList.remove(TOGGLE_CLASSES.PARTLY_OPACITY);\r\n    selectedWatch.resetBtn\r\n    .classList.add(TOGGLE_CLASSES.PARTLY_OPACITY);\r\n    selectedWatch.pauseBtn\r\n    .classList.add(TOGGLE_CLASSES.PARTLY_OPACITY);\r\n    selectedWatch.reset();            \r\n}\r\n\r\n/**\r\n * Performs all actions needed to be done when the pause button\r\n * is pressed. Changing opacity of buttons and stops \r\n * the counting of the internal timer.\r\n * \r\n * @param {!StopWatch} selectedWatch - stop watch do all the actions on \r\n * @param {!boolean} [createdFromStorage=false] - if true according \r\n * buttons will be highlighted   \r\n *  \r\n */\r\nexport function actionBtnPause(selectedWatch, createdFromStorage = false) {\r\n    selectedWatch.pause();            \r\n    if ( \r\n        createdFromStorage === true  || \r\n        selectedWatch.CurrentState !== StopWatch.States.reset\r\n        ) {\r\n        selectedWatch.playBtn\r\n        .classList.remove(TOGGLE_CLASSES.PARTLY_OPACITY);            \r\n        selectedWatch.pauseBtn\r\n        .classList.add(TOGGLE_CLASSES.PARTLY_OPACITY);\r\n        selectedWatch.resetBtn\r\n        .classList.remove(TOGGLE_CLASSES.PARTLY_OPACITY);\r\n    }\r\n}\r\n\r\n/**\r\n * Performs all actions needed to be done when the delete button\r\n * is pressed. Removing the stop watch from the dom\r\n * \r\n * @param {Array<StopWatch>} stopWatchList - list of all spawned stop watches on the\r\n * webpage\r\n * @param {!HTMLElement} separationBar - reference to the html element\r\n * for representing a separation bar.\r\n * @param {!object|!HTMLElement} selectedWatch - either an instance\r\n * as stop watch or the reference to the delete icon in the dom \r\n *  \r\n */\r\nexport function actionBtnDelete(stopWatchList, separationBar, selectedWatch ) {\r\n    let index = -1;\r\n\r\n    if ( selectedWatch.constructor.name === \"HTMLElement\") {\r\n        index = stopWatchList.findIndex(\r\n            stopWatch => \r\n            selectedWatch === stopWatch.trashBtn\r\n        )\r\n        \r\n    } else {\r\n        index = stopWatchList.indexOf(selectedWatch);\r\n    }\r\n    \r\n\r\n    if (index !== -1) {\r\n        stopWatchList[index].remove();\r\n        stopWatchList.splice(index, 1);                                            \r\n        if (stopWatchList.length === 0) {\r\n            toggleVisibility(separationBar, false);\r\n        } \r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Performs all actions needed to be done when the trash all button\r\n * is pressed. Removing the all stop watches from the webpage\r\n * \r\n * @param {!HTMLElement} separationBar - reference to the html element\r\n * for representing a separation bar.\r\n * @param {Array<StopWatch>} stopWatchList - list of all spawned stop watches on the\r\n * webpage\r\n * \r\n */\r\nexport function actionBtnDeleteAll(separationBar, stopWatchList) {\r\n    for (const stopWatch of stopWatchList) {            \r\n        stopWatch.remove();                                            \r\n    }\r\n    stopWatchList.length = 0;\r\n    \r\n    toggleVisibility(separationBar, false);    \r\n}\r\n","// @ts-check\r\nimport { textTimeUnitsToSeconds } from \"./ConverterFunctions.js\";\r\nimport * as htmlManipulation from \"./Html_Manipulation.js\";\r\nimport { QS, TOGGLE_CLASSES, STORAGE_KEYS } from \"./Constants.js\";\r\n\r\nimport { StopWatch } from \"./Modules/StopWatch.js\";\r\n\r\nwindow.addEventListener(\"DOMContentLoaded\", () => {\r\n\"use strict\";\r\n\r\n// SW = stopwatch\r\n// QS = querySelector\r\n/**\r\n * The box which holds all widgets for the user to spawn stop watches \r\n * and configure how spawned stop watches will behave \r\n *  \r\n * @const\r\n * @type {HTMLElement}\r\n */\r\nconst spawnBoxStopWatch = document.querySelector(QS.SPAWN_BOX);\r\n/**\r\n * List for holding all spawned stop watches on the page\r\n * \r\n * @const\r\n * @type {HTMLElement}\r\n */\r\nconst containerForStopWatches = document.querySelector(QS.LIST_SW);\r\n/**\r\n * Resides in the spawn box\r\n * Text input field in which the user can enter a name for the \r\n * next stop watch to be spawned\r\n * \r\n * @const\r\n * @type {HTMLInputElement}\r\n */ \r\nconst inputFieldLableStopWatch = document\r\n.querySelector(QS.INPUT_LABLE_FIELD);\r\n/**\r\n * Resides in the spawn box\r\n * On clicking it, it spawns a stop watch and appends as child\r\n * into containerForStopWatches\r\n * \r\n * @const\r\n * @type {HTMLElement}\r\n */\r\nconst spawnBtn = document.querySelector(QS.SPAWN_BTN);\r\n/**\r\n * Resides in the spawn box\r\n * On clicking it, it removes all spawned stop watches\r\n * \r\n * @const\r\n * @type {HTMLElement}\r\n */\r\nconst trashAllBtn = document.querySelector(QS.TRASH_ALL_BTN);\r\n/**\r\n * On clicking it in the spawn box, it toggles the counting direction \r\n * of up or down of the next stop watch to be spawned\r\n * \r\n * @const\r\n * @type {HTMLElement}\r\n */\r\nconst countDirectionBtn = document.querySelector(QS.COUNT_DIRECTION_BTN);\r\n/**\r\n * Resides in the spawn box\r\n * Input field where the user provides the seconds for the starting time \r\n * of the next stopwatch\r\n * \r\n * @const\r\n * @type {HTMLInputElement}\r\n */\r\nconst startSecondsInput = document.querySelector(QS.INPUT_SECONDS);        \r\n/**\r\n * Resides in the spawn box\r\n * Input field where the user provides the minutes for the starting time \r\n * of the next stopwatch\r\n * \r\n * @const\r\n * @type {HTMLInputElement}\r\n */\r\nconst startMinutesInput = document.querySelector(QS.INPUT_MINUTES);\r\n/**\r\n * Resides in the spawn box\r\n * Input field where the user provides the hours for the starting time \r\n * of the next stopwatch\r\n * \r\n * @const\r\n * @type {HTMLInputElement}\r\n */\r\nconst startHoursInput = document.querySelector(QS.INPUT_HOURS);\r\n/**\r\n * If user provides invalid input for the starting time this dom\r\n * element appears always under the spawn box. if the next input \r\n * for starting time is valid it disappears.\r\n * \r\n * @const\r\n * @type {HTMLElement}\r\n */\r\nconst errorBarInDom = document.querySelector(QS.ERROR_BAR_STARTIME);\r\n/**\r\n * Resides in the spawn box\r\n * Indicates if the stop watch will count up or down. It is indicates \r\n * the direction with its color and pointing up or down\r\n * \r\n * @const  \r\n * @type {HTMLElement}\r\n */\r\nconst counterArrowSpawn = document.querySelector(QS.COUNTER_ARROW_SPAWN);\r\n/**\r\n * Is placed below the spawn box or the error bar to show\r\n * separation between spawn box and actual stop watches\r\n * \r\n * @const\r\n * @type {HTMLElement}\r\n */\r\nconst separationBar = document.querySelector(QS.SEPARATION_BAR);\r\n\r\nconst countDirectionInformation = new Map();\r\n// The 2 possible texts and title pop ups \r\n// the button for counting direction can show\r\ncountDirectionInformation.set(false, \r\n    {\r\n        btnText: \"Count Down ?\",\r\n        titleText:         \r\n        \"Next stop watch will count up, Click to let next stop watch count down\"                                \r\n    }\r\n);\r\ncountDirectionInformation.set(true,\r\n    {\r\n        btnText: \"Count Up ?\",\r\n        titleText:\r\n        \"Next stop watch will count down, Click to let next stop watch count up\"\r\n    }\r\n);\r\n\r\nconst countArrowInformation = new Map();\r\n// 2 possible title pop ups an arrow for showing the counting direction\r\n// can have\r\ncountArrowInformation.set(false, \"Stop watch will count up\");\r\ncountArrowInformation.set(true, \"Stop watch will count down\");        \r\n\r\n/**\r\n * List of stopwatches which are currently active. An active stop watch in placed in \r\n * the dom of the page so the can interact with it.\r\n * \r\n * @type {Array<StopWatch>}\r\n */\r\nlet stopWatchList = [];\r\n\r\n// Set up functions via closure\r\nconst manageErrorBar = htmlManipulation.manageErrorBar.bind( null, errorBarInDom);\r\n\r\nconst toggleVisibility = htmlManipulation.toggleVisibility;\r\nconst toggleCountDirectionBtn = htmlManipulation.toggleCountDirectionBtn.bind(\r\n    null, countDirectionBtn, countDirectionInformation\r\n);\r\nconst toggleCounterSpawnerArrow = htmlManipulation.toggleCounterSpawnerArrow.bind(\r\n    null, countArrowInformation\r\n);\r\n\r\nconst actionBtnReset = htmlManipulation.actionBtnReset;\r\nconst actionBtnPause = htmlManipulation.actionBtnPause;\r\nconst actionBtnPlay = htmlManipulation.actionBtnPlay;\r\n\r\nconst actionBtnDelete = htmlManipulation.actionBtnDelete.bind(\r\n    null, stopWatchList, separationBar            \r\n);\r\nconst actionBtnDeleteAll = htmlManipulation.actionBtnDeleteAll.bind(\r\n    null, separationBar, stopWatchList\r\n);\r\n    \r\n/* Attaching events */\r\n// Attaching events for the spawn watch box    \r\n// Adding event for spawn manage button            \r\nspawnBoxStopWatch.addEventListener(\"click\", callbackClickSpawnBox);\r\n\r\ncontainerForStopWatches.addEventListener(\"click\", callBackStopWatchContainer);\r\n\r\n// For the user to interact with keyboard on the page\r\ndocument.addEventListener(\"keyup\", callbackPress);\r\n\r\n// Reading the session storage for restoring state before page reload\r\n\r\n/**\r\n * If true the next stop watch to spawn will count down\r\n * If false it will count up\r\n * \r\n * The value is toggled whenever the user clicks on the button \r\n * accessible via variable countDirectionBtn \r\n * \r\n * @type {boolean | undefined} \r\n */\r\nlet countDownGlobal = JSON.parse(sessionStorage.getItem(STORAGE_KEYS.GLOBAL_COUNT_DIRECTION));\r\ncountDownGlobal = countDownGlobal ?? false;\r\n\r\n// Setting the direction button up with its inner text and and its tooltip title\r\ntoggleCountDirectionBtn(countDownGlobal);\r\n// Setting up the arrow for showing the counting direction for the nex stop watch\r\ntoggleCounterSpawnerArrow(countDownGlobal, counterArrowSpawn);\r\n\r\n// Recreating stored stop watches from session storage after page reload\r\nconst stopWatchesState = sessionStorage.getItem(STORAGE_KEYS.STOP_WATCHES);\r\n\r\n// Checks if stop watches were present before the page reload\r\nif (stopWatchesState !== null && stopWatchesState !== \"\") {\r\n    const stopWatchesObjList = JSON.parse(stopWatchesState); \r\n    \r\n    stopWatchesObjList.forEach( uncreatedStopWatch => {                \r\n        const createdStopWatch =  StopWatch.CreateFromJSObject(uncreatedStopWatch);\r\n\r\n        integrateStopWatch(createdStopWatch);\r\n        const lastState = uncreatedStopWatch.currentState;\r\n\r\n        // Perform the respective actions to toggle the button visibility and\r\n        // brings the created stop watch to the right state for example starts a stop watch\r\n        if ( lastState === StopWatch.States.counting ) {\r\n            actionBtnPlay(createdStopWatch);                    \r\n        } else if ( lastState === StopWatch.States.paused ) {\r\n            actionBtnPause(createdStopWatch, true);\r\n        } else {\r\n            actionBtnReset(createdStopWatch);\r\n        }                 \r\n\r\n    });\r\n}\r\n\r\n// Saving the states of stop watches for recreating stop watches after page reload\r\nconst intervall = setInterval( () => {\r\n    \r\n    if (stopWatchList.length === 0) {\r\n        sessionStorage.setItem(STORAGE_KEYS.STOP_WATCHES, \"\");\r\n    } else {            \r\n        let listOfSavedStopWatches = [];\r\n        for (const unsavedStopWatch of stopWatchList) {\r\n            listOfSavedStopWatches.push(unsavedStopWatch.jsObjectState);\r\n        } \r\n        \r\n        sessionStorage.setItem(\r\n            STORAGE_KEYS.STOP_WATCHES, \r\n            JSON.stringify(listOfSavedStopWatches)\r\n        );\r\n    }         \r\n},1000);\r\n\r\n// Debug Area\r\nif (containerForStopWatches.querySelector(\".stop-watch\") === null) {\r\n    CreateStopWatch();\r\n}\r\n\r\n/* Functions */\r\n\r\n/**\r\n * Execution for all events related to the spawn box for stop watches\r\n * \r\n * When clicked on spawn button, a stop watch is spawned\r\n * When clicked on trash all button, all stop watches are removed\r\n * When clicked on count direction, it toggles the next stop watch \r\n * between counting up or down\r\n * \r\n * @callback  \r\n */\r\nfunction callbackClickSpawnBox(event) {    \r\n    /**\r\n     * @type {any}\r\n     */\r\n    const target = event.target;\r\n    \r\n    if (target === spawnBtn) {\r\n\r\n        const lableText = inputFieldLableStopWatch.value.trim();\r\n        inputFieldLableStopWatch.value = \"\";\r\n        \r\n        CreateStopWatch(lableText);             \r\n    } else if (target.parentNode === trashAllBtn) {                \r\n        actionBtnDeleteAll();\r\n    } else if (target === countDirectionBtn) {\r\n        \r\n        countDownGlobal = !countDownGlobal;\r\n        sessionStorage.setItem(STORAGE_KEYS.GLOBAL_COUNT_DIRECTION, JSON.stringify(countDownGlobal));\r\n        toggleCounterSpawnerArrow(countDownGlobal, counterArrowSpawn);\r\n        toggleCountDirectionBtn(countDownGlobal);\r\n    }\r\n}\r\n\r\n/**\r\n * :TODO Implement deleting all stop watches by pressing keyboard\r\n * \r\n * @param {!object} event \r\n * @callback \r\n */\r\nfunction callbackPress (event) {\r\n    const eventTarget = event.target;\r\n    const key = event.code;\r\n                \r\n    const pressedEnter = key === \"Enter\";\r\n    const pressedBackspace = key ===\"Backspace\";\r\n    const pressedDelete = key === \"Delete\";  \r\n    \r\n    if (pressedEnter || pressedBackspace || pressedDelete) {\r\n        // Here the user presses the input field of for starting\r\n        // time of a stop watch\r\n        if ( \r\n            (pressedEnter || pressedDelete) &&\r\n            (\r\n                eventTarget === inputFieldLableStopWatch ||\r\n                eventTarget === startSecondsInput ||\r\n                eventTarget === startMinutesInput ||\r\n                eventTarget === startHoursInput\r\n            )\r\n        ) {        \r\n            if (pressedDelete) {                        \r\n                actionBtnDeleteAll();\r\n            } else {\r\n                const lableText = inputFieldLableStopWatch.value.trim();\r\n                inputFieldLableStopWatch.value = \"\";\r\n                CreateStopWatch(lableText);\r\n            }            \r\n            \r\n        } else {\r\n                                                    \r\n            const focusedWatch = stopWatchList.find(\r\n                stopwatch => stopwatch.domReference === eventTarget\r\n            );\r\n\r\n            if (typeof focusedWatch !== \"undefined\") {\r\n                if (pressedEnter) {\r\n                    if (\r\n                        focusedWatch.CurrentState === StopWatch.States.counting                                \r\n                        ) {\r\n                        actionBtnPause(focusedWatch);\r\n                    } else {\r\n                        actionBtnPlay(focusedWatch);                            \r\n                    }\r\n                } else if (pressedBackspace) {\r\n                    actionBtnReset(focusedWatch);\r\n                } else {\r\n                    actionBtnDelete(focusedWatch);\r\n                }\r\n            }\r\n\r\n        } \r\n    } \r\n}\r\n\r\n\r\n/**\r\n * Handles all events related to a stop watch\r\n * \r\n * When clicked on the play button, the stop watch starts or resumes the counting.\r\n * When clicked on the pause button, the stop watch stops counting.\r\n * When clicked on the reset button, the stop watch reverts back to the start time and pauses.\r\n * When clicked on the trash button, the stop watch is removed on the page.\r\n * \r\n * @callback\r\n */\r\nfunction callBackStopWatchContainer(event) {\r\n    /**\r\n     * @type {any}\r\n     */\r\n    const target = event.target;\r\n\r\n    // If the play button is clicked\r\n    if ( StopWatch.isAPlyBtn( target ) === true ) {\r\n\r\n        for (const stopWatch of stopWatchList) {\r\n            if (stopWatch.playBtn === target) {                        \r\n                actionBtnPlay(stopWatch);                        \r\n            }                \r\n        }\r\n    // If the trash button is clicked\r\n    } else if ( StopWatch.isATrashBtn(target) ) {                              \r\n        actionBtnDelete(target);\r\n    // If the pause button is clicked \r\n    } else if ( StopWatch.isAPauseBtn(target) ) { \r\n        for (const stopWatch of stopWatchList) {\r\n            if (stopWatch.pauseBtn == target) {       \r\n                actionBtnPause(stopWatch);\r\n            }                \r\n        }   \r\n    // If the reset button is clicked \r\n    } else if ( StopWatch.isAResetBtn(target) ) {\r\n        for (const stopWatch of stopWatchList) {    \r\n            if (stopWatch.resetBtn === target) {    \r\n                actionBtnReset(stopWatch);\r\n            }    \r\n        }\r\n    } else if ( StopWatch.isASaveBtn(target) ) {\r\n        for (const stopWatch of stopWatchList) {    \r\n            if (stopWatch.saveBtn === target) {    \r\n                stopWatch.setCheckPoint();\r\n            }    \r\n        }\r\n    }\r\n\r\n}\r\n    \r\n/**\r\n * Validates the input of the user.\r\n * If valid, creates the a stop watch instance and returns it .\r\n * \r\n * \r\n * @param {!string} [lableText=\"Stop Watch\"] - (optional) Title of stop watch box \r\n * to be spawned.\r\n * @param {?number} [totalSeconds=null] - (optional) the time which a stop watch starts\r\n * counting from  if not provided the starting time\r\n * for a stop watch will taken from the input starting time widget in the spawn box\r\n * @param {!boolean} [countDown] (optional) if false the stop watch will count up\r\n * if true the stop watch will count down. if not provided the countDownGlobal variable\r\n * is taken for this parameter\r\n *\r\n * @returns {?StopWatch} Returns the created stop watch instance.\r\n * Returns null if the starting time from input starting time widget was not valid\r\n */\r\nfunction CreateStopWatch(\r\n    lableText=\"Stop Watch\", \r\n    totalSeconds=null, \r\n    countDown=countDownGlobal\r\n    ) {\r\n\r\n    // If null here the stop watch is created through clicking on the spawn button\r\n    // Grabbing starting time from the input starting time widget in the spawn box \r\n    if (totalSeconds === null) {\r\n        totalSeconds = validateStartingTime();\r\n    }\r\n\r\n    // if null here the the string from the spawn box is not valid for conversion into numbers\r\n    if (totalSeconds === null) {\r\n        return null;\r\n    }\r\n\r\n    const stopWatch = new StopWatch( lableText, totalSeconds );\r\n    stopWatch.countingDown = countDown;\r\n    // Giving the stop watch its starting time            \r\n    \r\n    integrateStopWatch(stopWatch);\r\n\r\n    return stopWatch;\r\n}\r\n\r\n/**\r\n * Appends the the stop watch html model in the proper position of dom tree\r\n * Toggles the visibility of the action buttons of the stop watch (like play button)\r\n * Adds stop watch to the global lis of all stop watch. \r\n * If needed, toggles the bar between the stop watch container and the spawn box. \r\n * \r\n * @param {!StopWatch} createdStopWatch - most recently created stop watch\r\n * to integrated\r\n */\r\nfunction integrateStopWatch(createdStopWatch) {\r\n    containerForStopWatches.appendChild(createdStopWatch.domReference);\r\n\r\n    // Making the pause and reset buttons half transparent.\r\n    createdStopWatch.pauseBtn\r\n    .classList.add(TOGGLE_CLASSES.PARTLY_OPACITY);\r\n    createdStopWatch.resetBtn\r\n    .classList.add(TOGGLE_CLASSES.PARTLY_OPACITY);\r\n    \r\n    // Giving the arrow which indicates the counting direction, \r\n    // the right appearance  \r\n    toggleCounterSpawnerArrow(\r\n        createdStopWatch.countingDown, \r\n        createdStopWatch.counterArrow\r\n    );\r\n                                            \r\n    stopWatchList.push( createdStopWatch ); \r\n\r\n    toggleSpawnBar();\r\n\r\n    createdStopWatch.domReference.tabIndex = 0;\r\n}\r\n\r\n// As soon as the 1. stop watch is spawned, a separation bar is shown\r\n// between the spawn box and the stop watches.\r\n\r\nfunction toggleSpawnBar() {\r\n    if (stopWatchList.length > 0) toggleVisibility(separationBar, true);\r\n}   \r\n\r\n/**\r\n * Grabs the starting time units from the spawn box and checks if\r\n * they are valid. If invalid does not create a stop watch box and shows\r\n * an error bar for the user.\r\n * \r\n * @returns {?number} - if valid input: totalSeconds of the seconds, \r\n * minutes and hours read from the input field for starting time \r\n * from the stop watch spawn box. \r\n * if invalid input: null \r\n */\r\nfunction validateStartingTime() {\r\n    // Getting values from the input fields for the starting time\r\n    const totalSeconds = textTimeUnitsToSeconds(\r\n    startSecondsInput.value,\r\n    startMinutesInput.value,\r\n    startHoursInput.value\r\n    );\r\n\r\n    // Resting the input field for starting time\r\n    startSecondsInput.value = \"0\";\r\n    startMinutesInput.value = \"0\";\r\n    startHoursInput.value = \"0\";\r\n    \r\n    // In case of invalid input for starting time an error bar\r\n    // as message is displayed to user.\r\n    if (totalSeconds === null) {\r\n        manageErrorBar(true);\r\n        return null;\r\n    }\r\n    else { \r\n        manageErrorBar(false);\r\n        return totalSeconds;\r\n    }\r\n}\r\n        \r\n});\r\n"]}